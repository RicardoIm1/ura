<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Computación I - Universidad URA</title>
  <link rel="stylesheet" href="estilos2.css">
  <style>
    /* Modal */
    #modal-info {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      z-index: 1000;
    }
    .modal-overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .modal-content {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -60%);
      background: #f5f5f5;
      padding: 30px;
      border-radius: 20px;
      max-width: 600px;
      width: 90%;
      opacity: 0;
      transition: transform 0.3s ease, opacity 0.3s ease;
      overflow-y: auto;
      max-height: 80%;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
      font-size: 1rem;
    }

    }
    .modal.show .modal-overlay {
      opacity: 1;
    }
    .modal.show .modal-content {
      transform: translate(-50%, -50%);
      opacity: 1;
    }
    .modal-close {
      position: absolute;
      top: 10px;
      right: 20px;
      font-size: 28px;
      cursor: pointer;
    }
    /* Ajuste de listas dentro del modal */
    #modal-text ul {
      margin-left: 20px;
      margin-bottom: 15px;
    }
    #modal-text h4 {
      margin-top: 20px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <a href="index.html">
        <img src="Logotipo-URA_curvas2-e1708836754389.png" alt="Logotipo URA" class="header-logo">
      </a>
      <div class="header-title">Computación I</div>
    </div>
  </header>

  <div class="hero">
    <h1>Computación I</h1>
    <h2>INAR0104</h2>
  </div>

  <section class="container">
    <h2 class="section-title">Objetivo General</h2>
    <p class="objetivo evaluacion-item tema-card">
      Al finalizar el curso el alumno será capaz de explicar el procesamiento de información por computadora, 
      utilizando la terminología técnica de identificación de los principales componentes de un sistema de computación,
      definiendo sus respectivas funciones, así como describir la historia de la computación y distinguir problemas susceptibles de soluciones mediante la computación.
    </p>
  </section>

  <section class="container">
    <h2 class="section-title">Temario</h2>
    <div class="temas-grid">
      <div class="tema-card">
        <div class="tema-num">TEMA 1</div>
        <h3 class="tema-title">Introducción a Computadores Digitales</h3>
        <ul class="tema-list">
          <li onclick="abrirModal('1.1 Computación Análoga', `
              <hr><br>
            <p><strong>Objetivo:</strong> Comprender qué es la computación análoga, cómo funciona y sus principales usos.</p>
            <h4>Definición</h4>
            <ul>
              <li>Modelo de computación que procesa información mediante magnitudes físicas continuas (voltaje, presión o movimiento).</li>
              <li>No trabaja con ceros y unos, sino con valores que cambian de manera constante dentro de un rango.</li>
            </ul>
            <h4>Características</h4>
            <ul>
              <li>Usa dispositivos mecánicos, eléctricos o hidráulicos.</li>
              <li>Ofrece resultados aproximados.</li>
              <li>Muy usada antes de la aparición de computadoras digitales.</li>
            </ul>
            <h4>Ejemplos</h4>
            <ul>
              <li>Regla de cálculo para operaciones matemáticas.</li>
              <li>Relojes de manecillas.</li>
              <li>Termómetros de mercurio.</li>
            </ul>
            <h4>Fuentes Bibliográficas</h4>
            <ul>
              <li>Rojas, R. (2000). <em>Historia de las máquinas de calcular y de los ordenadores</em>. Springer.</li>
              <li>Stein, C. (2018). <em>Analog Computing: Techniques and Applications</em>. Wiley.</li>
              <li>Tanenbaum, A. S. (2015). <em>Structured Computer Organization</em>. Pearson.</li>
            </ul>
          `)">1.1 Computación Análoga <span class="emoji-small">✅</span>
          </li>

          <ul class="tema-list">
            <li onclick="abrirModal('1.2 Introducción a métodos digitales', `
                <hr><br>
              <p><strong>Objetivo:</strong> Comprender qué son los métodos digitales, cómo funcionan y su relevancia en la computación moderna y la ciencia de la información.</p>

            <h4>Definición</h4>
            <ul>
              <li>Conjunto de técnicas y procedimientos que permiten representar, procesar, analizar y manipular información utilizando sistemas discretos.</li>
              <li>Convierte datos del mundo real en valores discretos (generalmente binarios) para su almacenamiento, transmisión y procesamiento mediante computadoras.</li>
              <li>Base de la computación digital, presente en smartphones, sistemas de control industrial, análisis de datos clínicos y prácticamente toda tecnología moderna.</li>
            </ul>

            <h4>Características</h4>
            <ul>
              <li>Trabaja con información discreta en lugar de continua, usando ceros y unos como lenguaje fundamental.</li>
              <li>Permite precisión, reproducibilidad y facilidad de manipulación de datos.</li>
              <li>Capacidad de aplicar algoritmos complejos para resolver problemas que serían difíciles o imposibles de abordar con métodos análogos.</li>
              <li>Facilita el almacenamiento, la comunicación y el control de información de manera confiable y eficiente.</li>
              <li>Sirve de soporte a simulaciones, modelado y análisis de datos en diversas áreas del conocimiento.</li>
            </ul>

            <h4>Ejemplos</h4>
            <ul>
              <li>Computadoras personales y servidores que procesan información digital.</li>
              <li>Smartphones y tablets que ejecutan aplicaciones basadas en datos discretos.</li>
              <li>Sistemas de control industrial, como robots y automatización de fábricas.</li>
              <li>Dispositivos médicos que digitalizan señales biológicas para diagnóstico y monitoreo.</li>
            </ul>

            <h4>Fuentes Bibliográficas</h4>
            <ul>
              <li>Tanenbaum, A. S. (2015). <em>Structured Computer Organization</em>. Pearson.</li>
              <li>Rojas, R. (2000). <em>Historia de las máquinas de calcular y de los ordenadores</em>. Springer.</li>
              <li>Stallings, W. (2018). <em>Computer Organization and Architecture</em>. Pearson.</li>
          </ul>
            `)">1.2 Introducción a métodos digitales <span class="emoji-small">✅</span>
          </li>

          <ul class="tema-list">
            <li onclick="abrirModal('1.3 Descripción de componentes', `
                <hr><br>
                <p><strong>Objetivo:</strong> Conocer los principales componentes de un sistema digital, su funcionamiento y cómo interactúan para procesar información.</p>

                <h4>Definición</h4>
                <ul>
                  <li>Los componentes de un sistema digital son los elementos físicos y lógicos que permiten la representación, procesamiento, almacenamiento y comunicación de información en forma discreta.</li>
                  <li>Incluyen tanto hardware (circuitos, procesadores, memoria, periféricos) como software (sistemas operativos y programas) que controlan el flujo y la manipulación de datos.</li>
                  <li>Son la base de cualquier dispositivo digital moderno, desde microcontroladores hasta supercomputadoras.</li>
                </ul>

                <h4>Principales Componentes</h4>
                <ul>
                  <li><strong>Unidad Central de Procesamiento (CPU):</strong> Componente encargado de ejecutar instrucciones, procesar datos y coordinar el funcionamiento de todo el sistema.</li>
                  <li><strong>Memoria:</strong> Almacena datos e instrucciones de manera temporal (RAM) o permanente (ROM, discos, memorias flash).</li>
                  <li><strong>Dispositivos de Entrada:</strong> Permiten la interacción con el sistema, como teclados, sensores, micrófonos y cámaras.</li>
                  <li><strong>Dispositivos de Salida:</strong> Permiten mostrar o transmitir información procesada, como pantallas, impresoras o actuadores en sistemas de control.</li>
                  <li><strong>Bus de Datos:</strong> Conjunto de líneas que transportan información entre la CPU, memoria y periféricos.</li>
                  <li><strong>Controladores y Interfaces:</strong> Administran la comunicación con dispositivos externos y aseguran que los datos se transfieran correctamente.</li>
                  <li><strong>Software de Sistema:</strong> Sistemas operativos y firmware que gestionan recursos y permiten ejecutar aplicaciones.</li>
                </ul>

                <h4>Características</h4>
                <ul>
                  <li>Interconexión eficiente entre componentes, permitiendo un flujo de información rápido y confiable.</li>
                  <li>Capacidad de procesamiento secuencial y paralelo mediante CPU y otros procesadores especializados.</li>
                  <li>Almacenamiento jerárquico, que permite acceso rápido a datos frecuentes y conservación a largo plazo de información crítica.</li>
                  <li>Modularidad, facilitando la actualización y sustitución de componentes sin afectar el funcionamiento general.</li>
                  <li>Compatibilidad entre hardware y software para ejecutar algoritmos y procesos de manera correcta.</li>
                </ul>

                <h4>Ejemplos</h4>
                <ul>
                  <li>Un microcontrolador Arduino que integra CPU, memoria y puertos de entrada/salida para proyectos electrónicos.</li>
                  <li>Computadoras personales con CPU, RAM, disco duro, tarjeta gráfica y periféricos conectados mediante buses.</li>
                  <li>Servidores de datos que utilizan múltiples CPUs, memorias de alta velocidad y sistemas redundantes para garantizar disponibilidad.</li>
                  <li>Smartphones que combinan procesador, memoria, sensores y sistemas operativos móviles en un solo dispositivo compacto.</li>
                </ul>

                <h4>Fuentes Bibliográficas</h4>
                <ul>
                  <li>Tanenbaum, A. S. (2015). <em>Structured Computer Organization</em>. Pearson.</li>
                  <li>Stallings, W. (2018). <em>Computer Organization and Architecture</em>. Pearson.</li>
                  <li>Rojas, R. (2000). <em>Historia de las máquinas de calcular y de los ordenadores</em>. Springer.</li>
                  <li>Hennessy, J., & Patterson, D. (2019). <em>Computer Architecture: A Quantitative Approach</em>. Morgan Kaufmann.</li>
                </ul>
            </ul>
          `)">1.3 Descricpción de componentes  <span class="emoji-small">✅</span>  
          </li>

          <ul class="tema-list">
            <li onclick="abrirModal('1.4 Lectura de entrada', `
              <hr><br>
              <p><strong>Objetivo:</strong> Entender cómo los sistemas digitales reciben información del mundo exterior y la preparan para su procesamiento interno.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>La lectura de entrada se refiere al proceso mediante el cual un sistema digital captura datos desde dispositivos o sensores externos para ser procesados por la CPU.</li>
                <li>Convierte señales físicas (como presión, luz, sonido o movimiento) en información discreta que puede ser entendida y manipulada por el sistema.</li>
                <li>Es el primer paso para la interacción entre el mundo real y los sistemas digitales, permitiendo la automatización, control y análisis de datos.</li>
              </ul>
            
              <h4>Principales Dispositivos de Entrada</h4>
              <ul>
                <li><strong>Teclados y ratones:</strong> Permiten ingresar datos y comandos de forma directa.</li>
                <li><strong>Sensores:</strong> Capturan información física como temperatura, presión, luz o humedad.</li>
                <li><strong>Micrófonos y cámaras:</strong> Digitalizan señales de audio y video para procesamiento y almacenamiento.</li>
                <li><strong>Lectores de código:</strong> Incluyen códigos de barras y QR que convierten información codificada en datos legibles por el sistema.</li>
                <li><strong>Dispositivos táctiles y pantallas interactivas:</strong> Permiten la interacción directa con interfaces gráficas y aplicaciones.</li>
                <li><strong>Interfaces de red:</strong> Reciben información proveniente de otros sistemas digitales a través de protocolos de comunicación.</li>
              </ul>
            
              <h4>Características</h4>
              <ul>
                <li>Transforma señales analógicas o físicas en información digital interpretable.</li>
                <li>Precisión y fidelidad en la captura de datos para asegurar un procesamiento confiable.</li>
                <li>Velocidad de respuesta suficiente para mantener sincronización con el procesamiento interno.</li>
                <li>Compatibilidad con los estándares de comunicación y formatos de datos del sistema.</li>
                <li>Posibilidad de integración con múltiples dispositivos simultáneamente para sistemas complejos.</li>
              </ul>
            
              <h4>Ejemplos</h4>
              <ul>
                <li>Un sensor de temperatura conectado a un microcontrolador para controlar un sistema de climatización.</li>
                <li>La cámara de un smartphone que captura imágenes y video para aplicaciones de reconocimiento facial.</li>
                <li>Lectores de tarjetas RFID que permiten el acceso seguro a instalaciones o sistemas electrónicos.</li>
                <li>Teclados y pantallas táctiles en cajeros automáticos que registran la información del usuario.</li>
                <li>Micrófonos digitales que capturan audio para asistentes de voz y sistemas de dictado.</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Tanenbaum, A. S. (2015). <em>Structured Computer Organization</em>. Pearson.</li>
                <li>Stallings, W. (2018). <em>Computer Organization and Architecture</em>. Pearson.</li>
                <li>Hennessy, J., & Patterson, D. (2019). <em>Computer Architecture: A Quantitative Approach</em>. Morgan Kaufmann.</li>
                <li>Rojas, R. (2000). <em>Historia de las máquinas de calcular y de los ordenadores</em>. Springer.</li>
              </ul>
            `)">1.4 Lectura de entrada  <span class="emoji-small">✅</span>
           </li>

        <ul class="tema-list">
          <li <li onclick="abrirModal('1.5 Unidad de memoria', `
              <hr><br>
              <p><strong>Objetivo:</strong> Comprender la función, tipos y características de la memoria en un sistema computacional.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>La unidad de memoria es el componente del computador responsable de almacenar datos e instrucciones para su posterior procesamiento.</li>
                <li>Actúa como un almacén temporal o permanente de información que puede ser accedida rápidamente por la CPU.</li>
                <li>Es fundamental para el funcionamiento de cualquier sistema digital, ya que determina la capacidad de almacenamiento y la velocidad de acceso a la información.</li>
              </ul>
            
              <h4>Tipos de Memoria</h4>
              <ul>
                <li><strong>Memoria Principal (RAM):</strong> Memoria de acceso aleatorio volátil que almacena temporalmente datos y programas en ejecución.</li>
                <li><strong>Memoria ROM:</strong> Memoria de solo lectura no volátil que contiene instrucciones fundamentales para el arranque del sistema.</li>
                <li><strong>Memoria Caché:</strong> Memoria de alta velocidad que almacena copias de datos frecuentemente accedidos para acelerar el procesamiento.</li>
                <li><strong>Memoria Virtual:</strong> Extensión de la memoria principal que utiliza espacio en el almacenamiento secundario.</li>
                <li><strong>Memoria Flash:</strong> Memoria no volátil utilizada en dispositivos de almacenamiento como SSDs y unidades USB.</li>
              </ul>
            
              <h4>Características</h4>
              <ul>
                <li><strong>Capacidad:</strong> Cantidad de información que puede almacenar, medida en bytes (KB, MB, GB, TB).</li>
                <li><strong>Velocidad de acceso:</strong> Tiempo que tarda la CPU en acceder a los datos almacenados.</li>
                <li><strong>Volatilidad:</strong> Determina si la información se mantiene o se pierde al apagar el sistema.</li>
                <li><strong>Método de acceso:</strong> Forma en que se accede a la información (aleatorio, secuencial, directo).</li>
                <li><strong>Tecnología:</strong> Implementación física de la memoria (semiconductores, magnética, óptica).</li>
              </ul>
            
              <h4>Ejemplos</h4>
              <ul>
                <li>Los módulos DDR4 en computadoras modernas que permiten multitarea eficiente.</li>
                <li>La memoria ROM BIOS que contiene el firmware necesario para iniciar el sistema operativo.</li>
                <li>Memoria caché L3 en procesadores Intel Core i7 que acelera el acceso a datos frecuentes.</li>
                <li>Memoria flash en tarjetas SD utilizadas en cámaras digitales y smartphones.</li>
                <li>Memoria virtual implementada en el disco duro para extender la capacidad de la RAM.</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Patterson, D. A., & Hennessy, J. L. (2017). <em>Computer Organization and Design: The Hardware/Software Interface</em>. Morgan Kaufmann.</li>
                <li>Stallings, W. (2020). <em>Computer Organization and Architecture: Designing for Performance</em>. Pearson.</li>
                <li>Null, L., & Lobur, J. (2018). <em>The Essentials of Computer Organization and Architecture</em>. Jones & Bartlett Learning.</li>
                <li>Hamacher, C., Vranesic, Z., & Zaky, S. (2011). <em>Computer Organization</em>. McGraw-Hill.</li>
              </ul>
            `)">1.5 Unidad de memoria <span class="emoji-small">✅</span>
          </li>

          <ul class="tema-list">
          <li <li onclick="abrirModal('1.6 Almacenamiento en código', `
              <hr><br>
              <p><strong>Objetivo:</strong> Analizar los métodos y formatos utilizados para almacenar información en sistemas digitales mediante codificación.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>El almacenamiento en código se refiere a la representación de información mediante sistemas de codificación que permiten su preservación y recuperación.</li>
                <li>Implica la transformación de datos en formatos digitales que pueden ser interpretados por los sistemas computacionales.</li>
                <li>Es fundamental para la persistencia de datos y la interoperabilidad entre diferentes sistemas y aplicaciones.</li>
              </ul>
            
              <h4>Métodos de Codificación</h4>
              <ul>
                <li><strong>Sistemas numéricos:</strong> Representación de información usando binario, octal, hexadecimal y decimal.</li>
                <li><strong>Códigos de caracteres:</strong> Sistemas como ASCII, Unicode y UTF-8 para representar texto.</li>
                <li><strong>Formatos de archivo:</strong> Estructuras específicas para diferentes tipos de datos (texto, imagen, audio, video).</li>
                <li><strong>Compresión de datos:</strong> Técnicas para reducir el espacio de almacenamiento (lossless y lossy).</li>
                <li><strong>Codificación para detección y corrección de errores:</strong> Métodos como paridad, Hamming y CRC.</li>
              </ul>
            
              <h4>Características</h4>
              <ul>
                <li><strong>Eficiencia:</strong> Optimización del espacio requerido para almacenar información.</li>
                <li>Integridad: Capacidad de detectar y corregir errores en los datos almacenados.</li>
                <li>Interoperabilidad: Compatibilidad entre diferentes sistemas y plataformas.</li>
                <li>Seguridad: Protección de datos mediante técnicas de cifrado y codificación.</li>
                <li>Escalabilidad: Adaptación a volúmenes crecientes de información.</li>
              </ul>
            
              <h4>Ejemplos</h4>
              <ul>
                <li>El código ASCII que representa caracteres alfanuméricos como números binarios.</li>
                <li>Formatos de imagen como JPEG y PNG que utilizan diferentes algoritmos de compresión.</li>
                <li>Archivos comprimidos ZIP que reducen el tamaño mediante algoritmos lossless.</li>
                <li>Base de datos que almacenan información en tablas con relaciones codificadas.</li>
                <li>Sistemas de cifrado como AES que codifican información para proteger su confidencialidad.</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Tanenbaum, A. S., & Austin, T. (2016). <em>Structured Computer Organization</em>. Pearson.</li>
                <li>Khan, Z. (2018). <em>Data Representation in Computer Systems</em>. Springer.</li>
                <li>Salomon, D. (2007). <em>Data Compression: The Complete Reference</em>. Springer.</li>
                <li>Unicode Consortium. (2020). <em>The Unicode Standard</em>. Unicode, Inc.</li>
              </ul>
            `)">1.6. Almacenamiento en código <span class="emoji-small">✅</span>
          </li>
          
        <ul class="tema-list">
          <li <li onclick="abrirModal('1.7 Números binarios', `
              <hr><br>
              <p><strong>Objetivo:</strong> Comprender el sistema binario, su importancia en computación y las operaciones fundamentales con números binarios.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>El sistema binario es un sistema de numeración posicional que utiliza solo dos dígitos: 0 y 1.</li>
                <li>Es la base del funcionamiento de los sistemas digitales, ya que los componentes electrónicos pueden representar fácilmente dos estados (encendido/apagado, verdadero/falso).</li>
                <li>Permite representar cualquier tipo de información (números, texto, imágenes, sonido) mediante combinaciones de bits.</li>
              </ul>
            
              <h4>Conceptos Fundamentales</h4>
              <ul>
                <li><strong>Bit:</strong> Unidad básica de información que representa un dígito binario (0 o 1).</li>
                <li><strong>Byte:</strong> Grupo de 8 bits que representa un carácter o unidad de información básica.</li>
                <li><strong>Conversión entre sistemas:</strong> Métodos para transformar números entre binario, decimal, octal y hexadecimal.</li>
                <li><strong>Aritmética binaria:</strong> Operaciones matemáticas (suma, resta, multiplicación, división) con números binarios.</li>
                <li><strong>Representación de números negativos:</strong> Sistemas como signo-magnitud, complemento a uno y complemento a dos.</li>
                <li><strong>Punto flotante:</strong> Representación de números reales mediante notación científica en binario.</li>
              </ul>
            
              <h4>Características</h4>
              <ul>
                <li>Simplicidad de implementación en circuitos electrónicos.</li>
                <li>Fiabilidad en la representación y transmisión de datos.</li>
                <li>Eficiencia en operaciones lógicas y aritméticas.</li>
                <li>Escalabilidad para representar información compleja.</li>
                <li>Universalidad como estándar en sistemas digitales.</li>
              </ul>
            
              <h4>Ejemplos</h4>
              <ul>
                <li>Representación del número decimal 10 como 1010 en binario.</li>
                <li>Suma binaria: 1010 (10) + 0110 (6) = 10000 (16).</li>
                <li>Representación del carácter 'A' en ASCII como el número binario 01000001.</li>
                <li>Uso del complemento a dos para representar números negativos.</li>
                <li>Almacenamiento de imágenes mediante valores binarios que representan píxeles.</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Mano, M. M., & Ciletti, M. D. (2018). <em>Digital Design: With an Introduction to the Verilog HDL</em>. Pearson.</li>
                <li>Null, L., & Lobur, J. (2014). <em>Essentials of Computer Organization and Architecture</em>. Jones & Bartlett Learning.</li>
                <li>Khan, M. (2019). <em>Binary Arithmetic and Boolean Algebra</em>. McGraw-Hill.</li>
                <li>IEEE Computer Society. (2019). <em>IEEE Standard for Floating-Point Arithmetic</em>. IEEE Std 754-2019.</li>
              </ul>
            `)">1.7. Números binarios <span class="emoji-small">✅</span>
          </li>

          <ul class="tema-list">
          <li onclick="abrirModal('1.8 Organización de los componentes fundamentales del computador', `
              <hr><br>
              <p><strong>Objetivo:</strong> Identificar y comprender la interconexión y funcionamiento de los componentes principales de un sistema computacional.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>La organización de componentes se refiere a la disposición estructural y las interconexiones entre las unidades funcionales de un computador.</li>
                <li>Define cómo los diferentes componentes (CPU, memoria, E/S) interactúan para ejecutar instrucciones y procesar datos.</li>
                <li>Establece la arquitectura básica que determina el rendimiento, eficiencia y capacidades del sistema.</li>
              </ul>
            
              <h4>Componentes Principales</h4>
              <ul>
                <li><strong>Unidad Central de Procesamiento (CPU):</strong> Cerebro del computador que ejecuta instrucciones y procesa datos.</li>
                <li><strong>Memoria Principal:</strong> Almacena datos e instrucciones necesarios para la ejecución de programas.</li>
                <li><strong>Dispositivos de Entrada/Salida:</strong> Permiten la comunicación entre el computador y el exterior.</li>
                <li><strong>Buses del Sistema:</strong> Canales de comunicación que interconectan los componentes del computador.</li>
                <li><strong>Unidad de Control:</strong> Coordina las actividades de todos los componentes del sistema.</li>
                <li><strong>Almacenamiento Secundario:</strong> Provee capacidad de almacenamiento no volátil a largo plazo.</li>
              </ul>
            
              <h4>Características</h4>
              <ul>
                <li>Arquitectura definida por el conjunto de instrucciones y organización de hardware.</li>
                <li>Jerarquía de memoria que equilibra velocidad, capacidad y costo.</li>
                <li>Mecanismos de interrupción para gestionar eventos asíncronos.</li>
                <li>Técnicas de paralelismo para mejorar el rendimiento.</li>
                <li>Modos de direccionamiento para acceder a datos e instrucciones.</li>
              </ul>
            
              <h4>Ejemplos</h4>
              <ul>
                <li>Arquitectura Von Neumann con unidad de procesamiento, memoria y buses unificados.</li>
                <li>Arquitectura Harvard con memorias separadas para datos e instrucciones.</li>
                <li>Sistemas multiprocesador con varias CPUs compartiendo recursos.</li>
                <li>Computadoras con buses PCI Express para alta velocidad de transferencia.</li>
                <li>Sistemas con memoria caché multinivel para reducir latencia.</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Stallings, W. (2019). <em>Computer Organization and Architecture: Designing for Performance</em>. Pearson.</li>
                <li>Patterson, D. A., & Hennessy, J. L. (2017). <em>Computer Organization and Design: The Hardware/Software Interface</em>. Morgan Kaufmann.</li>
                <li>Tanenbaum, A. S. (2015). <em>Structured Computer Organization</em>. Pearson.</li>
                <li>Hennessy, J., & Patterson, D. (2019). <em>Computer Architecture: A Quantitative Approach</em>. Morgan Kaufmann.</li>
              </ul>
            `)">1.8. Organización de los componentes fundamentales del computador <span class="emoji-small">✅</span>
          </li>

        <ul class="tema-list">
          <li  onclick="abrirModal('1.9 Instrucciones en lenguaje de máquina', `
              <hr><br>
              <p><strong>Objetivo:</strong> Analizar la estructura, tipos y funcionamiento de las instrucciones en lenguaje de máquina que ejecuta directamente el procesador.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>Las instrucciones en lenguaje de máquina son comandos en formato binario que la CPU puede ejecutar directamente.</li>
                <li>Representan las operaciones más básicas que puede realizar un computador, específicas para cada arquitectura de procesador.</li>
                <li>Forman el conjunto de instrucciones (instruction set) que define las capacidades fundamentales de un procesador.</li>
              </ul>
            
              <h4>Tipos de Instrucciones</h4>
              <ul>
                <li><strong>Transferencia de datos:</strong> Mover información entre memoria, registros y dispositivos.</li>
                <li><strong>Aritméticas:</strong> Realizar operaciones matemáticas como suma, resta, multiplicación y división.</li>
                <li><strong>Lógicas:</strong> Operaciones booleanas como AND, OR, NOT y XOR.</li>
                <li><strong>Control de flujo:</strong> Alterar la secuencia de ejecución (saltos, bifurcaciones, llamadas a subrutinas).</li>
                <li><strong>Manejo de dispositivos:</strong> Controlar operaciones de entrada/salida con periféricos.</li>
              </ul>
            
              <h4>Características</h4>
              <ul>
                <li>Codificadas en formato binario específico para cada arquitectura.</li>
                <li>Ejecutadas directamente por el hardware del procesador.</li>
                <li>Organizadas en ciclos de instrucción (fetch, decode, execute).</li>
                <li>Diferentes modos de direccionamiento para acceder a operandos.</li>
                <li>Varían en longitud y complejidad según la arquitectura (CISC vs RISC).</li>
              </ul>
            
              <h4>Ejemplos</h4>
              <ul>
                <li>Instrucción ADD en x86: 00000011 11000011 (suma los registros AX y BX).</li>
                <li>Instrucción LOAD en arquitectura MIPS: 100011 00001 00010 0000000000000000.</li>
                <li>Salto condicional JZ (Jump if Zero) en ensamblador x86.</li>
                <li>Instrucción MOV para transferencia de datos en múltiples arquitecturas.</li>
                <li>Llamada a interrupción INT en x86 para solicitar servicios del sistema operativo.</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Patterson, D. A., & Hennessy, J. L. (2017). <em>Computer Organization and Design: The Hardware/Software Interface</em>. Morgan Kaufmann.</li>
                <li>Intel Corporation. (2019). <em>Intel 64 and IA-32 Architectures Software Developer's Manual</em>.</li>
                <li>ARM Limited. (2020). <em>ARM Architecture Reference Manual</em>.</li>
                <li>Sweetman, D. (2006). <em>See MIPS Run</em>. Morgan Kaufmann.</li>
              </ul>
            `)">1.9. Instrucciones en lenguaje de máquina <span class="emoji-small">✅</span>
          </li>
        </ul>            
      </div>
      
      <div class="tema-card">
        <div class="tema-num">TEMA 2</div>
        <h3 class="tema-title">Programación</h3>
        <ul class="tema-list">
          <li onclick="abrirModal('2.1. Programación', `
            <hr><br>
            <p><strong>Objetivo:</strong> Comprender los conceptos fundamentales, características y aplicaciones de la programación como disciplina esencial en la informática.</p>
            
            <h4>Definición</h4>
            <ul>
              <li>La programación es el <span style='color: #e74c3c;'>proceso de crear un conjunto de instrucciones</span> que le dicen a una computadora cómo realizar una tarea específica.</li>
              <li>Consiste en <span style='color: #3498db;'>escribir, probar, depurar y mantener</span> el código fuente de programas computacionales.</li>
              <li>Es una disciplina que combina <span style='color: #2ecc71;'>lógica, algoritmos y estructuras de datos</span> para resolver problemas.</li>
            </ul>
            
            <h4>Elementos Fundamentales</h4>
            <ul>
              <li><strong>Algoritmos:</strong> Secuencia lógica de pasos para resolver un problema.</li>
              <li><strong>Lenguajes de programación:</strong> Conjunto de reglas y sintaxis para escribir programas.</li>
              <li><strong>Estructuras de datos:</strong> Formas de organizar y almacenar información.</li>
              <li><strong>Paradigmas de programación:</strong> Estilos y metodologías para desarrollar software.</li>
              <li><strong>Herramientas de desarrollo:</strong> Editores, compiladores, depuradores, etc.</li>
            </ul>
          
            <h4>Proceso de Desarrollo de Software</h4>
            <ol>
              <li><span style='color: #e74c3c;'>Análisis de requisitos</span>: Comprender qué debe hacer el programa.</li>
              <li><span style='color: #e74c3c;'>Diseño del algoritmo</span>: Planificar la solución al problema.</li>
              <li><span style='color: #e74c3c;'>Codificación</span>: Escribir el código en un lenguaje de programación.</li>
              <li><span style='color: #e74c3c;'>Pruebas y depuración</span>: Verificar que el programa funcione correctamente.</li>
              <li><span style='color: #e74c3c;'>Documentación</span>: Explicar cómo funciona el programa.</li>
              <li><span style='color: #e74c3c;'>Mantenimiento</span>: Actualizar y mejorar el programa.</li>
            </ol>
          
            <h4>Paradigmas de Programación Principales</h4>
            <ul>
              <li><strong>Programación estructurada:</strong> Uso de secuencias, selecciones e iteraciones.</li>
              <li><strong>Programación orientada a objetos (POO):</strong> Basada en objetos y clases.</li>
              <li><strong>Programación funcional:</strong> Uso de funciones matemáticas puras.</li>
              <li><strong>Programación imperativa:</strong> Describe cómo lograr un objetivo paso a paso.</li>
              <li><strong>Programación declarativa:</strong> Describe qué se quiere lograr, no cómo.</li>
            </ul>
          
            <h4>Niveles de Lenguajes de Programación</h4>
            <ul>
              <li><strong>Lenguaje máquina:</strong> Código binario ejecutado directamente por el hardware.</li>
              <li><strong>Lenguaje ensamblador:</strong> Representación simbólica del lenguaje máquina.</li>
              <li><strong>Lenguajes de alto nivel:</strong> Más cercanos al lenguaje humano (Python, Java, C++).</li>
              <li><strong>Lenguajes de muy alto nivel:</strong> Especializados en dominios específicos.</li>
            </ul>
          
            <h4>Aplicaciones de la Programación</h4>
            <ul>
              <li><strong>Desarrollo web:</strong> Sitios y aplicaciones web.</li>
              <li><strong>Inteligencia artificial:</strong> Machine learning, redes neuronales.</li>
              <li><strong>Videojuegos:</strong> Desarrollo de software de entretenimiento.</li>
              <li><strong>Sistemas embebidos:</strong> Control de dispositivos electrónicos.</li>
              <li><strong>Ciencia de datos:</strong> Análisis y visualización de datos.</li>
              <li><strong>Aplicaciones móviles:</strong> Software para smartphones y tablets.</li>
            </ul>
          
            <h4>Habilidades del Programador</h4>
            <ul>
              <li>Pensamiento lógico y algorítmico.</li>
              <li>Capacidad de resolución de problemas.</li>
              <li>Atención al detalle.</li>
              <li>Trabajo en equipo y colaboración.</li>
              <li>Aprendizaje continuo y adaptación.</li>
              <li>Creatividad e innovación.</li>
            </ul>
          
            <h4>Fuentes Bibliográficas</h4>
            <ul>
              <li>Kernighan, B. W., & Ritchie, D. M. (1988). <em>El lenguaje de programación C</em>. Prentice Hall.</li>
              <li>Gamma, E., Helm, R., Johnson, R., & Vlissides, J. (1994). <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley.</li>
              <li>Knuth, D. E. (1997). <em>The Art of Computer Programming</em>. Addison-Wesley.</li>
              <li>McConnell, S. (2004). <em>Code Complete: A Practical Handbook of Software Construction</em>. Microsoft Press.</li>
              <li>Martin, R. C. (2008). <em>Clean Code: A Handbook of Agile Software Craftsmanship</em>. Prentice Hall.</li>
            </ul>
          `)">2.1. Descripción general <span class="emoji-small">✅</span>
        </li>
          
      <ul class"tema-list>          
        <li onclick="abrirModal('2.2. Tipos de proposiciones', `
            <hr><br>
            <p><strong>Objetivo:</strong> Identificar y clasificar los diferentes tipos de proposiciones lógicas según su estructura y características fundamentales.</p>
          
            <h4>Definición de Proposición</h4>
            <ul>
              <li>Una proposición es una <span style='color: #e74c3c;'>oración declarativa</span> que puede ser calificada como verdadera o falsa, pero no ambas.</li>
              <li>Debe tener un <span style='color: #3498db;'>valor de verdad definido</span> (verdadero o falso).</li>
              <li>No puede ser una pregunta, orden o exclamación.</li>
            </ul>
          
            <h4>Clasificación Principal</h4>
            <ul>
              <li><strong>Proposiciones simples o atómicas:</strong> No contienen otras proposiciones como partes.</li>
              <li><strong>Proposiciones compuestas o moleculares:</strong> Formadas por la combinación de proposiciones simples.</li>
            </ul>
          
            <h4>Proposiciones Simples</h4>
            <ul>
              <li><span style='color: #e74c3c;'>Características:</span>
                <ul>
                  <li>Expresan una única idea</li>
                  <li>No pueden dividirse en proposiciones más pequeñas</li>
                  <li>Se representan con letras minúsculas (p, q, r, s...)</li>
                </ul>
              </li>
              <li><span style='color: #3498db;'>Ejemplos:</span>
                <ul>
                  <li>'El sol es una estrella' (Verdadera)</li>
                  <li>'2 + 3 = 6' (Falsa)</li>
                  <li>'Lima es la capital de Perú' (Verdadera)</li>
                </ul>
              </li>
            </ul>
          
            <h4>Proposiciones Compuestas</h4>
            <ul>
              <li><span style='color: #e74c3c;'>Conectivos lógicos:</span> Palabras que unen proposiciones simples</li>
              <li><span style='color: #3498db;'>Tipos según el conectivo:</span>
                <ol>
                  <li><strong>Conjunción (∧):</strong> 'p y q' - Es verdadera solo cuando ambas son verdaderas</li>
                  <li><strong>Disyunción (∨):</strong> 'p o q' - Es falsa solo cuando ambas son falsas</li>
                  <li><strong>Condicional (→):</strong> 'Si p entonces q' - Es falsa solo cuando p es verdadera y q falsa</li>
                  <li><strong>Bicondicional (↔):</strong> 'p si y solo si q' - Es verdadera cuando ambas tienen el mismo valor</li>
                  <li><strong>Negación (¬):</strong> 'No p' - Invierte el valor de verdad</li>
                </ol>
              </li>
            </ul>
          
            <h4>Clasificación por Modalidad</h4>
            <ul>
              <li><strong>Proposiciones afirmativas:</strong> Afirman algo sobre un sujeto</li>
              <li><strong>Proposiciones negativas:</strong> Niegan algo sobre un sujeto</li>
              <li><strong>Proposiciones universales:</strong> Aplican a todos los elementos de un conjunto</li>
              <li><strong>Proposiciones particulares:</strong> Aplican a algunos elementos de un conjunto</li>
            </ul>
          
            <h4>Proposiciones según la Lógica Aristotélica</h4>
            <ul>
              <li><strong>Tipo A:</strong> Universal afirmativa - 'Todo S es P'</li>
              <li><strong>Tipo E:</strong> Universal negativa - 'Ningún S es P'</li>
              <li><strong>Tipo I:</strong> Particular afirmativa - 'Algún S es P'</li>
              <li><strong>Tipo O:</strong> Particular negativa - 'Algún S no es P'</li>
            </ul>
          
            <h4>Ejemplos de Proposiciones Compuestas</h4>
            <ul>
              <li><span style='color: #2ecc71;'>Conjunción:</span> 'Hace sol y hace calor'</li>
              <li><span style='color: #2ecc71;'>Disyunción:</span> 'Estudiaré matemáticas o física'</li>
              <li><span style='color: #2ecc71;'>Condicional:</span> 'Si llueve, entonces cancelaremos el picnic'</li>
              <li><span style='color: #2ecc71;'>Bicondicional:</span> 'Un triángulo es equilátero si y solo si tiene tres lados iguales'</li>
              <li><span style='color: #2ecc71;'>Negación:</span> 'No es cierto que la Tierra sea plana'</li>
            </ul>
          
            <h4>Reglas para Identificar Proposiciones</h4>
            <ol>
              <li><span style='color: #e74c3c;'>Verificar que sea una oración declarativa</span></li>
              <li><span style='color: #e74c3c;'>Confirmar que tenga valor de verdad definido</span></li>
              <li><span style='color: #e74c3c;'>Excluir preguntas, órdenes y exclamaciones</span></li>
              <li><span style='color: #e74c3c;'>Identificar si es simple o compuesta</span></li>
              <li><span style='color: #e74c3c;'>Determinar los conectivos lógicos presentes</span></li>
            </ol>
          
            <h4>Fuentes Bibliográficas</h4>
            <ul>
              <li>Copi, I. M., & Cohen, C. (2011). <em>Introducción a la lógica</em>. Limusa.</li>
              <li>Irving, M. (2009). <em>Lógica y teoría de conjuntos</em>. Universidad Nacional Autónoma de México.</li>
              <li>Quine, W. V. O. (1981). <em>Métodos de lógica</em>. Ariel.</li>
              <li>Suppes, P. (2012). <em>Introduction to Logic</em>. Dover Publications.</li>
              <li>Tarski, A. (1995). <em>Introducción a la lógica y a la metodología de las ciencias deductivas</em>. Espasa-Calpe.</li>
            </ul>
          `)">2.2. Tipos de proposiciones <span class="emoji-small">✅</span>
        </li>
       <ul class="tema-list">
        <li onclick="abrirModal('2.3. Proposiciones de asignación aritmética', `
          <hr><br>
          <p><strong>Objetivo:</strong> Comprender y aplicar las proposiciones de asignación aritmética en programación, incluyendo su sintaxis, operadores y uso en algoritmos.</p>
        
          <h4>Definición</h4>
          <ul>
            <li>Una proposición de asignación aritmética es una <span style='color: #e74c3c;'>instrucción que asigna un valor</span> a una variable mediante una expresión aritmética.</li>
            <li>Es una de las <span style='color: #3498db;'>operaciones fundamentales</span> en la mayoría de los lenguajes de programación.</li>
            <li>Sigue la estructura: <span style='color: #2ecc71;'>variable = expresión_aritmética</span></li>
          </ul>
        
          <h4>Sintaxis Básica</h4>
          <ul>
            <li><strong>Operador de asignación:</strong> = (igual) en la mayoría de lenguajes</li>
            <li><strong>Variable destino:</strong> Recibe el resultado de la expresión</li>
            <li><strong>Expresión aritmética:</strong> Combinación de variables, constantes y operadores</li>
            <li><strong>Terminador:</strong> ; (punto y coma) en lenguajes como C, Java, JavaScript</li>
          </ul>
        
          <h4>Operadores Aritméticos</h4>
          <ul>
            <li><strong>Suma:</strong> + (ejemplo: x = a + b)</li>
            <li><strong>Resta:</strong> - (ejemplo: y = c - d)</li>
            <li><strong>Multiplicación:</strong> * (ejemplo: z = e * f)</li>
            <li><strong>División:</strong> / (ejemplo: w = g / h)</li>
            <li><strong>Módulo:</strong> % (resto de la división, ejemplo: r = i % j)</li>
            <li><strong>Potenciación:</strong> ** o ^ (depende del lenguaje)</li>
          </ul>
        
          <h4>Tipos de Asignación Aritmética</h4>
          <ul>
            <li><strong>Asignación simple:</strong> Variable = expresión</li>
            <li><strong>Asignación compuesta:</strong> Combinación con operadores (+=, -=, *=, /=)</li>
            <li><strong>Asignación múltiple:</strong> Varias variables en una sola instrucción</li>
            <li><strong>Asignación con incremento/decremento:</strong> ++, -- (prefijo y sufijo)</li>
          </ul>
        
          <h4>Reglas de Precedencia de Operadores</h4>
          <ol>
            <li><span style='color: #e74c3c;'>Paréntesis</span> (siempre tienen la máxima prioridad)</li>
            <li><span style='color: #e74c3c;'>Potenciación</span> (si está disponible)</li>
            <li><span style='color: #e74c3c;'>Multiplicación, División y Módulo</span> (de izquierda a derecha)</li>
            <li><span style='color: #e74c3c;'>Suma y Resta</span> (de izquierda a derecha)</li>
            <li><span style='color: #e74c3c;'>Asignación</span> (generalmente la menor prioridad)</li>
          </ol>
        
          <h4>Ejemplos en Diferentes Lenguajes</h4>
          <ul>
            <li><strong>Python:</strong>
              <ul>
                <li>x = 5 + 3 * 2  # x = 11</li>
                <li>y = (5 + 3) * 2  # y = 16</li>
                <li>z = 10 // 3  # división entera, z = 3</li>
              </ul>
            </li>
            <li><strong>Java/C/JavaScript:</strong>
              <ul>
                <li>int a = 10 + 5 * 2;  // a = 20</li>
                <li>double b = 15.0 / 4.0;  // b = 3.75</li>
                <li>int c = 17 % 5;  // c = 2</li>
              </ul>
            </li>
            <li><strong>Asignaciones compuestas:</strong>
              <ul>
                <li>total += precio  // equivalente a total = total + precio</li>
                <li>contador -= 1  // equivalente a contador = contador - 1</li>
              </ul>
            </li>
          </ul>
        
          <h4>Errores Comunes y Consideraciones</h4>
          <ul>
            <li><span style='color: #e74c3c;'>División por cero:</span> Provoca error en tiempo de ejecución</li>
            <li><span style='color: #3498db;'>Desbordamiento:</span> Cuando el resultado excede el rango de la variable</li>
            <li><span style='color: #2ecc71;'>Precisión en números decimales:</span> Errores de redondeo en operaciones con float/double</li>
            <li><span style='color: #f39c12;'>Variables no inicializadas:</span> Usar variables sin valor asignado previamente</li>
          </ul>
        
          <h4>Aplicaciones Prácticas</h4>
          <ul>
            <li>Cálculos matemáticos en programas científicos</li>
            <li>Procesamiento de datos numéricos</li>
            <li>Contadores y acumuladores en bucles</li>
            <li>Conversiones de unidades</li>
            <li>Cálculos financieros y estadísticos</li>
          </ul>
        
          <h4>Buenas Prácticas</h4>
          <ol>
            <li><span style='color: #e74c3c;'>Usar paréntesis</span> para clarificar la precedencia</li>
            <li><span style='color: #e74c3c;'>Inicializar variables</span> antes de usarlas</li>
            <li><span style='color: #e74c3c;'>Elegir el tipo de dato apropiado</span> para el cálculo</li>
            <li><span style='color: #e74c3c;'>Validar divisiones</span> para evitar división por cero</li>
            <li><span style='color: #e74c3c;'>Comentar operaciones complejas</span> para mejor legibilidad</li>
          </ol>
        
          <h4>Fuentes Bibliográficas</h4>
          <ul>
            <li>Kernighan, B. W., & Ritchie, D. M. (1988). <em>El lenguaje de programación C</em>. Prentice Hall.</li>
            <li>Deitel, P. J., & Deitel, H. M. (2016). <em>Cómo programar en Java</em>. Pearson Educación.</li>
            <li>Lutz, M. (2013). <em>Learning Python</em>. O'Reilly Media.</li>
            <li>Stroustrup, B. (2013). <em>The C++ Programming Language</em>. Addison-Wesley.</li>
            <li>Flanagan, D. (2020). <em>JavaScript: The Definitive Guide</em>. O'Reilly Media.</li>
          </ul>
        `)">2.3. Proposiciones de asignación aritmética <span class="emoji-small">✅</span>
        </li>
        
        
      <ul class="tema-list">
        <li onclick="abrirModal('2.4. Proposiciones de asignación lógica', `
              <hr><br>
              <p><strong>Objetivo:</strong> Comprender y utilizar las proposiciones de asignación lógica en programación, incluyendo operadores booleanos y su aplicación en condiciones y toma de decisiones.</p>
            
              <h4>Definición</h4>
              <ul>
                <li>Una proposición de asignación lógica es una <span style='color: #e74c3c;'>instrucción que asigna un valor booleano</span> (verdadero o falso) a una variable.</li>
                <li>Se basa en la <span style='color: #3498db;'>evaluación de expresiones lógicas</span> que resultan en true o false.</li>
                <li>Sigue la estructura: <span style='color: #2ecc71;'>variable = expresión_lógica</span></li>
              </ul>
            
              <h4>Operadores Lógicos Fundamentales</h4>
              <ul>
                <li><strong>AND (∧):</strong> Verdadero solo si ambos operandos son verdaderos</li>
                <li><strong>OR (∨):</strong> Falso solo si ambos operandos son falsos</li>
                <li><strong>NOT (¬):</strong> Invierte el valor de verdad</li>
                <li><strong>XOR (⊕):</strong> Verdadero si los operandos son diferentes</li>
              </ul>
            
              <h4>Tablas de Verdad</h4>
              <ul>
                <li><strong>AND:</strong>
                  <ul>
                    <li>true AND true = true</li>
                    <li>true AND false = false</li>
                    <li>false AND true = false</li>
                    <li>false AND false = false</li>
                  </ul>
                </li>
                <li><strong>OR:</strong>
                  <ul>
                    <li>true OR true = true</li>
                    <li>true OR false = true</li>
                    <li>false OR true = true</li>
                    <li>false OR false = false</li>
                  </ul>
                </li>
                <li><strong>NOT:</strong>
                  <ul>
                    <li>NOT true = false</li>
                    <li>NOT false = true</li>
                  </ul>
                </li>
              </ul>
            
              <h4>Operadores Relacionales en Asignaciones Lógicas</h4>
              <ul>
                <li><strong>Igualdad:</strong> == o === (depende del lenguaje)</li>
                <li><strong>Desigualdad:</strong> != o !==</li>
                <li><strong>Mayor que:</strong> ></li>
                <li><strong>Menor que:</strong> <</li>
                <li><strong>Mayor o igual que:</strong> >=</li>
                <li><strong>Menor o igual que:</strong> <=</li>
              </ul>
            
              <h4>Tipos de Asignaciones Lógicas</h4>
              <ul>
                <li><strong>Asignación directa:</strong> variable = true/false</li>
                <li><strong>Asignación por comparación:</strong> variable = (a > b)</li>
                <li><strong>Asignación con operadores lógicos:</strong> variable = (x && y) || z</li>
                <li><strong>Asignación condicional:</strong> variable = (condición) ? valor1 : valor2</li>
              </ul>
            
              <h4>Precedencia de Operadores Lógicos</h4>
              <ol>
                <li><span style='color: #e74c3c;'>Paréntesis</span> (máxima prioridad)</li>
                <li><span style='color: #e74c3c;'>Operadores relacionales</span> (>, <, >=, <=, ==, !=)</li>
                <li><span style='color: #e74c3c;'>NOT</span> (¬)</li>
                <li><span style='color: #e74c3c;'>AND</span> (∧)</li>
                <li><span style='color: #e74c3c;'>OR</span> (∨)</li>
                <li><span style='color: #e74c3c;'>Asignación</span> (=)</li>
              </ol>
            
              <h4>Ejemplos en Diferentes Lenguajes</h4>
              <ul>
                <li><strong>Python:</strong>
                  <ul>
                    <li>es_mayor = edad >= 18</li>
                    <li>es_valido = (nombre != '') and (edad > 0)</li>
                    <li>es_par = (numero % 2 == 0)</li>
                  </ul>
                </li>
                <li><strong>Java/JavaScript:</strong>
                  <ul>
                    <li>boolean aprobado = nota >= 6.0;</li>
                    <li>boolean puedeVotar = (edad >= 18) && (esCiudadano == true);</li>
                    <li>boolean esTriangulo = (a + b > c) && (a + c > b) && (b + c > a);</li>
                  </ul>
                </li>
                <li><strong>Asignaciones compuestas:</strong>
                  <ul>
                    <li>estado = !estado  // invierte el valor booleano</li>
                    <li>activado = activado || nuevo_estado  // se activa si alguno es true</li>
                  </ul>
                </li>
              </ul>
            
              <h4>Leyes de la Lógica Booleana</h4>
              <ul>
                <li><strong>Ley de identidad:</strong> A AND true = A, A OR false = A</li>
                <li><strong>Ley de dominación:</strong> A AND false = false, A OR true = true</li>
                <li><strong>Ley de idempotencia:</strong> A AND A = A, A OR A = A</li>
                <li><strong>Ley de complemento:</strong> A AND NOT A = false, A OR NOT A = true</li>
                <li><strong>Leyes de De Morgan:</strong> NOT (A AND B) = NOT A OR NOT B</li>
              </ul>
            
              <h4>Aplicaciones Prácticas</h4>
              <ul>
                <li>Validación de datos de entrada</li>
                <li>Control de flujo en condicionales (if, while)</li>
                <li>Sistemas de reglas y toma de decisiones</li>
                <li>Circuitos lógicos y electrónica digital</li>
                <li>Bases de datos y consultas booleanas</li>
                <li>Inteligencia artificial y sistemas expertos</li>
              </ul>
            
              <h4>Consideraciones Importantes</h4>
              <ul>
                <li><span style='color: #e74c3c;'>Evaluación de cortocircuito:</span> Algunos lenguajes evalúan solo lo necesario</li>
                <li><span style='color: #3498db;'>Conversión automática:</span> Cómo se convierten otros tipos a booleanos</li>
                <li><span style='color: #2ecc71;'>Precisión en comparaciones:</span> Cuidado con comparaciones de punto flotante</li>
                <li><span style='color: #f39c12;'>Legibilidad:</span> Usar paréntesis para clarificar expresiones complejas</li>
              </ul>
            
              <h4>Fuentes Bibliográficas</h4>
              <ul>
                <li>Kleene, S. C. (2002). <em>Mathematical Logic</em>. Dover Publications.</li>
                <li>Mendelson, E. (2015). <em>Introduction to Mathematical Logic</em>. Chapman and Hall.</li>
                <li>Boole, G. (1854). <em>An Investigation of the Laws of Thought</em>. Macmillan.</li>
                <li>Floyd, T. L. (2015). <em>Digital Fundamentals</em>. Pearson Education.</li>
                <li>Deitel, P. J., & Deitel, H. M. (2016). <em>Cómo programar en Java</em>. Pearson Educación.</li>
              </ul>
            `)">2.4. Proposiciones de asignación lógica <span class="emoji-small">✅</span>
        </li>


      <ul class="tema-list">
        <li onclick="abrirModal('2.5. Proposición de flujo', `
          <hr><br>
          <p><strong>Objetivo:</strong> Comprender las proposiciones de flujo de control que permiten alterar la secuencia de ejecución de un programa mediante estructuras condicionales e iterativas.</p>
        
          <h4>Definición</h4>
          <ul>
            <li>Una proposición de flujo es una <span style='color: #e74c3c;'>instrucción que controla el orden de ejecución</span> de las sentencias en un programa.</li>
            <li>Permite <span style='color: #3498db;'>alterar la secuencia lineal</span> de ejecución basándose en condiciones o repeticiones.</li>
            <li>Es fundamental para implementar <span style='color: #2ecc71;'>lógica de decisión y bucles</span> en programación.</li>
          </ul>
        
          <h4>Tipos de Proposiciones de Flujo</h4>
          <ul>
            <li><strong>Estructuras condicionales:</strong> Permiten ejecutar código basado en condiciones</li>
            <li><strong>Estructuras iterativas:</strong> Permiten repetir código múltiples veces</li>
            <li><strong>Estructuras de salto:</strong> Permiten transferir el control a otra parte del código</li>
            <li><strong>Estructuras de selección múltiple:</strong> Para casos con múltiples alternativas</li>
          </ul>
        
          <h4>Estructuras Condicionales</h4>
          <ul>
            <li><strong>IF simple:</strong> Ejecuta código si la condición es verdadera
              <ul>
                <li>if (condición) { código }</li>
              </ul>
            </li>
            <li><strong>IF-ELSE:</strong> Ejecuta un bloque u otro según la condición
              <ul>
                <li>if (condición) { código1 } else { código2 }</li>
              </ul>
            </li>
            <li><strong>IF-ELSE IF:</strong> Múltiples condiciones en cascada
              <ul>
                <li>if (cond1) { } else if (cond2) { } else { }</li>
              </ul>
            </li>
          </ul>
        
          <h4>Estructuras Iterativas (Bucles)</h4>
          <ul>
            <li><strong>WHILE:</strong> Repite mientras la condición sea verdadera
              <ul>
                <li>while (condición) { código }</li>
              </ul>
            </li>
            <li><strong>DO-WHILE:</strong> Ejecuta al menos una vez y luego repite mientras la condición sea verdadera
              <ul>
                <li>do { código } while (condición)</li>
              </ul>
            </li>
            <li><strong>FOR:</strong> Bucle con inicialización, condición e incremento
              <ul>
                <li>for (inicialización; condición; incremento) { código }</li>
              </ul>
            </li>
          </ul>
        
          <h4>Estructuras de Selección Múltiple</h4>
          <ul>
            <li><strong>SWITCH-CASE:</strong> Selecciona entre múltiples casos basados en un valor
              <ul>
                <li>switch (variable) { case valor1: código; break; case valor2: código; break; default: código; }</li>
              </ul>
            </li>
            <li><strong>Match (en lenguajes modernos):</strong> Pattern matching para selección avanzada</li>
          </ul>
        
          <h4>Instrucciones de Control de Flujo</h4>
          <ul>
            <li><strong>BREAK:</strong> Termina la ejecución de un bucle o switch</li>
            <li><strong>CONTINUE:</strong> Salta a la siguiente iteración de un bucle</li>
            <li><strong>RETURN:</strong> Retorna un valor y termina la ejecución de una función</li>
            <li><strong>GOTO:</strong> Salto incondicional (considerado mala práctica en programación moderna)</li>
          </ul>
        
          <h4>Flujo de Ejecución Paso a Paso</h4>
          <ol>
            <li><span style='color: #e74c3c;'>Evaluación de condición</span> en estructuras condicionales</li>
            <li><span style='color: #e74c3c;'>Ejecución selectiva</span> del bloque correspondiente</li>
            <li><span style='color: #e74c3c;'>Inicialización y verificación</span> en bucles</li>
            <li><span style='color: #e74c3c;'>Repetición controlada</span> con condición de terminación</li>
            <li><span style='color: #e74c3c;'>Salida del flujo controlado</span> y continuación del programa</li>
          </ol>
        
          <h4>Ejemplos Prácticos</h4>
          <ul>
            <li><strong>Condicional IF:</strong>
              <ul>
                <li>if (edad >= 18) { console.log('Mayor de edad'); } else { console.log('Menor de edad'); }</li>
              </ul>
            </li>
            <li><strong>Bucle FOR:</strong>
              <ul>
                <li>for (let i = 0; i < 10; i++) { console.log('Iteración: ' + i); }</li>
              </ul>
            </li>
            <li><strong>Bucle WHILE:</strong>
              <ul>
                <li>while (contador < 5) { console.log(contador); contador++; }</li>
              </ul>
            </li>
            <li><strong>SWITCH-CASE:</strong>
              <ul>
                <li>switch (diaSemana) { case 1: console.log('Lunes'); break; case 2: console.log('Martes'); break; default: console.log('Otro día'); }</li>
              </ul>
            </li>
          </ul>
        
          <h4>Anidamiento de Estructuras de Flujo</h4>
          <ul>
            <li>Los bucles pueden contener condicionales y viceversa</li>
            <li>Los condicionales pueden anidarse para lógica compleja</li>
            <li>Los bucles pueden anidarse para procesar estructuras multidimensionales</li>
            <li>Es importante mantener la legibilidad del código anidado</li>
          </ul>
        
          <h4>Buenas Prácticas en el Control de Flujo</h4>
          <ol>
            <li><span style='color: #e74c3c;'>Evitar bucles infinitos</span> asegurando condiciones de salida</li>
            <li><span style='color: #e74c3c;'>Mantener la legibilidad</span> con indentación consistente</li>
            <li><span style='color: #e74c3c;'>Usar break y continue</span> con moderación</li>
            <li><span style='color: #e74c3c;'>Preferir estructuras claras</span> sobre código complejo anidado</li>
            <li><span style='color: #e74c3c;'>Validar condiciones</span> antes de entrar en bucles</li>
          </ol>
        
          <h4>Aplicaciones en Algoritmos</h4>
          <ul>
            <li>Búsqueda y filtrado de datos</li>
            <li>Validación y procesamiento de entradas</li>
            <li>Implementación de menús y interfaces</li>
            <li>Procesamiento por lotes y iteraciones</li>
            <li>Control de estados y máquinas de estado</li>
          </ul>
        
          <h4>Fuentes Bibliográficas</h4>
          <ul>
            <li>Kernighan, B. W., & Ritchie, D. M. (1988). <em>El lenguaje de programación C</em>. Prentice Hall.</li>
            <li>McConnell, S. (2004). <em>Code Complete: A Practical Handbook of Software Construction</em>. Microsoft Press.</li>
            <li>Martin, R. C. (2008). <em>Clean Code: A Handbook of Agile Software Craftsmanship</em>. Prentice Hall.</li>
            <li>Gamma, E., et al. (1994). <em>Design Patterns: Elements of Reusable Object-Oriented Software</em>. Addison-Wesley.</li>
            <li>Knuth, D. E. (1997). <em>The Art of Computer Programming</em>. Addison-Wesley.</li>
          </ul>
        `)">2.5. Proposición de flujo <span class="emoji-small">✅</span>
        </li>

        <ul class="tema-list">
          <li>2.6. Diagramas</li>
        </ul>
    </div>
    
    <div class="tema-card">
      <div class="tema-num">TEMA 3</div>
      <h3 class="tema-title">Proposiciones Elementales y Formatos</h3>
      <ul class="tema-list">
        <li>3.1. Proposición de entrada</li>
        <li>3.2. Proposición de salida</li>
        <li>3.3. Proposición de control</li>
        <li>3.4. Proposición de formato</li>
        <li>3.5. Formato I</li>
        <li>3.6. Formato F</li>
        <li>3.7. Formato E</li>
        <li>3.8. Capacidades adicionales de formato</li>
        <li>3.9. Código holierith</li>
      </ul>
    </div>
    
    <div class="tema-card">
      <div class="tema-num">TEMA 4</div>
      <h3 class="tema-title">Funciones, Subrutinas y Subprogramas</h3>
      <ul class="tema-list">
        <li>4.1. Introducción</li>
        <li>4.2. Definiciones</li>
        <li>4.3. Tipos de subprogramas</li>
        <li>4.4. Formación de un subprograma</li>
        <li>4.5. Subprogramas de función</li>
        <li>4.6. Subprogramas de subrutinas</li>
        <li>4.7. Subprogramas combinados</li>
      </ul>
    </div>
    
    <div class="tema-card">
      <div class="tema-num">TEMA 5</div>
      <h3 class="tema-title">Paquetes de Subrutina Científicas</h3>
      <ul class="tema-list">
        <li>5.1. Introducción</li>
        <li>5.2. Ejemplos de paquetes</li>
        <li>5.3. Texas instrument TI-59</li>
        <li>5.4. Manejo de calculador</li>
        <li>5.5. Casio FX-502P</li>
        <li>5.6. Códigos</li>
        <li>5.7. Instrucciones</li>
        <li>5.8. Interpretación de datos</li>
        <li>5.9. Corrección de programas</li>
      </ul>
    </div>
  </div>
</section>

<section class="actividades">
  <h2 class="section-title">Actividades de Aprendizaje</h2>
  
  <div>
    <h3 class="actividades-subtitle">Bajo la conducción del docente en laboratorio de cómputo</h3>
    <div class="cards-grid">
      <div class="card">
        <h3>Ejercicios de diagramas de flujo</h3>
        <p>El alumno realizará ejercicios de diagramas de flujo con diversas propuestas.</p>
      </div>
      <div class="card">
        <h3>Elaboración de programas</h3>
        <p>El alumno elaborará programas utilizando formatos establecidos.</p>
      </div>
      <div class="card">
        <h3>Modificaciones a programas</h3>
        <p>Los alumnos efectuarán modificaciones a los programas realizados con subrutinas y subprogramas.</p>
      </div>
      <div class="card">
        <h3>Ejercicios con computadoras manuales</h3>
        <p>Se harán ejercicios con computadoras manuales Texas y Casio.</p>
      </div>
    </div>
  </div>
  
  <div style="margin-top: 70px;">
    <h3 class="actividades-subtitle">De manera independiente</h3>
    <div class="cards-grid">
      <div class="card">
        <h3>Investigación bibliográfica</h3>
        <p>El alumno hará una investigación bibliográfica de la historia de la computación y de los componentes de la misma, elaborando un resumen.</p>
      </div>
      <div class="card">
        <h3>Programas con proposiciones</h3>
        <p>Se hará un programa utilizando las proposiciones y formatos establecidos.</p>
      </div>
      <div class="card">
        <h3>Solución de problemas</h3>
        <p>Se resolverán problemas aplicados a cálculo mediante computadoras manuales.</p>
      </div>
    </div>
  </div>
</section>

<section class="container">
  <h2 class="section-title">Evaluación</h2>
  <div class="evaluacion-grid">
    <div class="evaluacion-item tema-card">
      <div class="evaluacion-porcentaje">40%</div>
      <p class="evaluacion-desc">Dos exámenes parciales</p>
    </div>
    <div class="evaluacion-item tema-card">
      <div class="evaluacion-porcentaje">20%</div>
      <p class="evaluacion-desc">Reporte de prácticas de laboratorio</p>
    </div>
    <div class="evaluacion-item tema-card">
      <div class="evaluacion-porcentaje">10%</div>
      <p class="evaluacion-desc">Investigaciones bibliográficas</p>
    </div>
    <div class="evaluacion-item tema-card">
      <div class="evaluacion-porcentaje">30%</div>
      <p class="evaluacion-desc">Examen final</p>
    </div>
  </div>
</section>

<!-- Modal -->
<div id="modal-info" class="modal">
  <div class="modal-overlay"></div>
  <div class="modal-content">
    <span class="modal-close">&times;</span>
    <h3 id="modal-title"></h3>
    <div id="modal-text"></div>
  </div>
</div>

<script>
  const modal = document.getElementById('modal-info');
  const modalTitle = document.getElementById('modal-title');
  const modalText = document.getElementById('modal-text');
  const modalClose = document.querySelector('.modal-close');
  const modalOverlay = document.querySelector('.modal-overlay');

  // Función para abrir modal con HTML
  function abrirModal(titulo, html) {
    modalTitle.textContent = titulo;
    modalText.innerHTML = html;
    modal.classList.add('show');
    modal.style.display = 'block';
  }

  // Función para cerrar modal
  function cerrarModal() {
    modal.classList.remove('show');
    setTimeout(() => modal.style.display = 'none', 300); // espera la transición
  }

  modalClose.addEventListener('click', cerrarModal);
  modalOverlay.addEventListener('click', cerrarModal);
</script>

<footer>
  © 2025 Universidad URA – Asignatura Computación I
</footer>
</body>
</html>
